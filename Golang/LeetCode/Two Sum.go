/*
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

Constraints:
2 <= nums.length <= 10**4
-10**9 <= nums[i] <= 10**9
-10**9 <= target <= 10**9
Only one valid answer exists.

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?
*/

// Решение задачи
// Комментарии буду писать на русском, т.к. заметки веду преимущественно для себя.
// Согласно условию, у нас не передаются из буфера какие-то значения, которые нам нужно принять,
// т.к. в указанном коде LeetCode нет функции main, она считается объявленной и там
// уже инициализированы переменные nums и target. Поэтому, момент получения значений мы опустим.
// Весь код нужно писать в объявленной программой функции twoSum

package main

import (
	"fmt"
	"math"
)

func main() {
	// Возможно, что код будет выглядеть и по факту быть гораздо больше, чем он должен быть достаточным для
	// получения решения, но код пишу для себя с использованием разных практик, что бы лучше понять как все работает,
	// для соблюдения всех условий и возможных вариантов.
	// В условии задачи указано, что nums является массивом, но в прописанной LeetCode'ом функции twoSum
	// она принимает два значение - интовый срез и число. Не совсем понятно, почему так происходит.
	// Предположим, что ошибка в описании и nums это срез.
	// Так же напоминаю, что на LeetCode отсутствует фукнция main и позразумевается, что все переменные там
	// уже объявлены и указаны условия соответствия диапозонов значений из Constraints, нам дается только функция twoSum
	// где нам нужно писать код. Поэтому, код main я пишу для себя.

	nums := []int{3, 2, 6, 6, 7, 1, 3, 1, 3}
	target := 6

	// Согласно условию, у нас есть ряд ограничений для nums.length, nums[i] и target.
	// С помощью свича отработаем соблюдения условий о длине среза (массива) и target
	switch {
	case len(nums) < 2 || len(nums) > int(math.Pow(10.0, 4.0)):
		fmt.Println("Error: 2 <= nums.length <= 10**4")
	case target < int(math.Pow(-10.0, 9.0)) || target > int(math.Pow(10.0, 9.0)):
		fmt.Println("Error: -10**9 <= nums[i] <= 10**9")
	default:
		fmt.Println(twoSum(nums, target))
	}
}

func twoSum(nums []int, target int) []int {
	// Согласно условию, у нас есть ряд ограничений к nums[i] ("-10**9 <= nums[i] <= 10**9"), которое мы
	// не могли предусмотреть в свиче функции main (в виду, того, что нужно делать итерацию по срезу, которая
	// будет лишним затратом ресурсов).
	// Можно было бы сделать сортировку списка по возрастанию значений и сразу понимать где заканчивать итерацию,
	// но тогда будет нарушена верность ответа, т.к. индексы верных значений тоже изменятся.
	// Не придумал, как правильно выводить ошибку и завершать код. Решил остановиться на панике, т.к.
	// согласно условию, функция twoSum возвращает только слайс, если было бы два значения, где второе err, то
	// было бы проще. Писать break внутри if нет смысла, т.к. break остановит одну из итераций цикла if внутри for,
	// но не сам код. Можно было бы завести некоторую переменную, как симафор ошибки, присваивая ей некоторые значения,
	// и в самом конце функции проверять на значение и выводить то или иное значение (например [-1] и текст ошибки)
	// Но данное решение является дорогим, в виду того, что ошибка не будет выведена до тех пор, пока программа
	// не выполнит все итерации в функции twoSum, тем самым сделает никому не нужную работу. Паника - пока лучшее
	// решение данного кейса.

	// В данный момент оптимальным выходом вижу итерацию for внутри for, что бы пробегаться сравнивая nums[i] с
	// остальными значениями внутри слайса. Оба цикла не будут пробегаться по range nums, т.к. необходимо описать
	// условия при которых цикл будет итерироваться. Что бы сберечь ресурсы и избежать лишних итерация (например, мы
	// нашли ответ, но код будет продолжать итерироваться и сравнивать элементы слайса, т.к. нет стоп фактора)
	// нам нужно условие, при выполнении которго, функция завершает код. Что бы не плодить лишних переменных-симофоров,
	// этим условием будет слайс answer. Если ответ был найдет, то слайс будет инилизирован и его len или cap будет > 0.
	// Если таких элементов в слайсе нет, то нет и смысла инилизировать слайс и занимать память, тогда вернем []int{-1}
	// и текст, что таких элементов нет.
	var answer []int

	for i := 0; len(answer) == 0 && i < len(nums); i++ {
		if nums[i] < int(math.Pow(-10.0, 9.0)) || nums[i] > int(math.Pow(10.0, 9.0)) {
			panic("Error: -10**9 <= nums[i] <= 10**9")
		}

		for n := i + 1; len(answer) == 0 && n < len(nums); n++ {
			if nums[i] == target-nums[n] {
				answer = append(answer, i, n)
			}
		}
	}

	if len(answer) != 0 {
		return answer
	} else {
		fmt.Println("The slice does not contain elements whose sum will be equal to the target value.")
		return []int{-1}
	}
}
